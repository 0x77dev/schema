---
id: api-reference
title: API Reference
sidebar_label: API Reference
---

<AUTOGENERATED_TABLE_OF_CONTENTS>

### `objectType(typeName, definitionBlockFn)`

The most common type, the `objectType` function builds a corresponding `type` definition in GraphQL terminology. The first argument is a string representing the "name" of the type. The second is a function which is passed a [`definitionBlockObject`](#definitionblockobject) to add all of the necessary fields & metadata to the type.

```js
const Post = objectType("Post", (t) => {
  t.implements("Node");
  t.description("A post is the primary resource on the blog", {
    property: "desc",
  });
  t.field("author", "User", { description: "Author of the field" });
  t.string("title", {
    description: "Title of the Post",
    default: "Untitled Post",
  });
  t.string("body", { description: "Body of the Post, formatted as Markdown" });
  t.field("status", "StatusEnum", {
    description:
      "Status of the post - all posts default to PENDING until published",
  });
  t.field("tags", "Tag", { list: true });
  t.field("createdAt", "Date");
  t.field("updatedAt", "Date", { nullable: true });
});
```

As you might also notice, there are several

The full API for the object passed to the `definitionBlockFn` is [documented here](#definitionblockobject).

### `inputObjectType(typeName, definitionBlockFn)`

Similar to `objectType`, the `inputObjectType` function builds

### `interfaceType(typeName, definitionBlockFn)`

Creates a `GraphQLInterfaceType` in a similar fashion to the

```js
const Node = interfaceType("Node", (t) => {
  t.id("id", { description: "ID of the Node", property: "_id" });
});
```

### `unionType(typeName, unionMember[])`

```js
const x
```

### `enumType(typeName, enumMembers | definitionBlockFn)`

```ts
type enumMembers = EnumMemberMap | EnumMemberList;

type EnumMemberMap = {};

type EnumMemberList = ["", "", ""];
```

### `scalarType(typeName, GraphQLScalarTypeConfig)`

The `scalarType` creates a

```js
const DateScalar = scalarType("Date", {
  description: "Date custom scalar type",
  parseValue(value) {
    return new Date(value);
  },
  serialize(value) {
    return value.getTime();
  },
  parseLiteral(ast) {
    if (ast.kind === Kind.INT) {
      return new Date(ast.value);
    }
    return null;
  },
});
```

### `abstractType(typeName, definitionBlock)`

The `abstractType` does not have a parallel in GraphQL terminology, and can be thought of as a partial, it draws from a similar concept in the [graphene python](https://docs.graphene-python.org/en/latest/types/abstracttypes/) library.

Abstract types may be "mixed" into concrete types using the `.mix()` method, though rather than mixing the type name as a string, mix is called with the object returned from `abstractType`.

It is the only object that does not have an associated "name", because there is no associated representation in the GraphQL schema.

### `makeSchema(SchemaOptions)`

The `makeSchema` function constructs the schema. It is a wrapper over the `GraphQLSchemaType` from `graphql-js`.

```js
const schema = makeSchema({
  types: [
    /* 
      All GraphQLiteral / GraphQLJS types should be provided here.
    */
  ],
});
```

```ts
type SchemaOptions = {
  types: Array<GraphQLNamedType | GraphQLiteralType>;
};
```

### `definitionBlockObject`

```ts
type DefinitionBlockObject = {
  /**
   * Adds a description to the top level
   */
  description(text: string): void;

  /**
   * Adds a field to the type
   */
  field(fieldName: string, typeName: string, fieldOptions: FieldOptions): void;

  /**
   * Adds a list field to the type
   */
  list(fieldName: string, typeName: string, listOptions: ListOptions): void;

  /**
   * Alias for .field(fieldName, "ID", fieldOptions)
   */
  id(fieldName: string, fieldOptions: FieldOptions): void;

  /**
   * Alias for .field(fieldName, "Int", fieldOptions)
   */
  int(fieldName: string, fieldOptions: FieldOptions): void;

  /**
   * Alias for .field(fieldName, "String", fieldOptions)
   */
  string(fieldName: string, fieldOptions: FieldOptions): void;

  /**
   * Specify at the type-level whether fields are considered null by default.
   * Takes precedence over `defaultNull` if it is set on the schema.
   */
  defaultNull(nullable: boolean): void;
};

type FieldOptions = {
  /**
   * Whether the field can return a null value.
   * Takes precedence over `defaultNull` if set on the type or schema.
   */
  nullable?: boolean;
};
```
