import {
  GraphQLSchema,
  schemaToTemplateContext,
  SchemaTemplateContext,
  Field,
  Argument,
} from "graphql-codegen-core";
import * as Types from "./types";

const SCALAR_TYPES = {
  Int: "number",
  String: "string",
  ID: "string",
  Float: "number",
  Date: "Date",
  JSON: "any",
  Boolean: "boolean",
};

export async function typegen(
  options: Types.GQLiteralTypegenOptions<any>,
  schema: GraphQLSchema
) {
  const fs = require("fs") as typeof import("fs");
  const context = schemaToTemplateContext(schema);
  const data = await makeTypes(options, context);
  await Promise.all(
    data.map(async ({ filename, content }) => {
      await new Promise((resolve, reject) => {
        fs.writeFile(filename, content, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    })
  );
  return options;
}

export const makeTypes = (
  options: Types.GQLiteralTypegenOptions<any>,
  context: SchemaTemplateContext
) => {
  const {
    typesFilePath,
    backingTypes: backing = {},
    typeGenPrefix: prefix = "Generated",
    prefix: headerPrefix = [],
  } = options;
  const backingTypes: Record<string, string> = {
    ...SCALAR_TYPES,
    ...backing,
  };
  const tmpl = `
  /* tslint:disable */
  /**
   * This file is automatically generated by gqliteral
   * Do not make changes directly
   */
  ${headerPrefix.join("\n")}

  ${map(context.interfaces, (i) => {
    const typeName = `${prefix}_Interface_${i.name}`;

    return `
      export interface ${typeName}_Fields {
        ${map(i.fields, (f) => fieldDef(typeName, f))}
      }

      export interface ${typeName} {
        implementingTypes: ${map(i.implementingTypes, (t) => `"${t}"`, "|")};
        backingType: ${map(i.implementingTypes, backingType, "|")};
        fields: ${typeName}_Fields
      };
    `;
  })}

  ${map(context.types, (t) => {
    const typeName = `${prefix}_Type_${t.name}`;
    return `
      ${map(nonInterfaceFields(context, t), (f) => {
        const args = f.hasArguments ? `${typeName}_Field_${f.name}_Args` : "{}";
        return `
          export interface ${typeName}_Field_${f.name} {
            returnType: ${getReturnType(f)};
            args: ${args};
          }
          ${
            f.hasArguments
              ? `
            export interface ${typeName}_Field_${f.name}_Args {
              ${map(f.arguments, (arg) => {
                const name = `${arg.name}${arg.isRequired ? ":" : "?:"}`;
                return `${name} ${getArgType(arg)}`;
              })}
            }
          `
              : ""
          }
        `;
      })}

      export interface ${typeName}_Fields ${interfaceFields(prefix, t)} {
        ${map(
          nonInterfaceFields(context, t),
          (f) => `${f.name}: ${typeName}_Field_${f.name}`
        )}
      }

      export interface ${typeName} {
        backingType: ${backingType(t.name)};
        fields: ${typeName}_Fields
      };
    `;
  })}

  export interface ${prefix}Scalars {
    ${map(context.scalars, (scalar) => `${scalar.name}: any;`)}
  }
  
  export interface ${prefix}Interfaces {
    ${map(
      context.interfaces,
      (i) => `${i.name}: ${prefix}_Interface_${i.name}`
    )}
  }

  export interface ${prefix}Unions {}
  
  export interface ${prefix}Enums {
    ${map(context.enums, (e) => {
      return `${e.name}: ${map(
        e.values,
        (v) => JSON.stringify(v.value),
        "|"
      )};`;
    })}
  }
  export interface ${prefix}InputObjects {
    ${map(context.inputTypes, (i) => {
      return `${i.name}: any; // TODO!!`;
    })}
  }
  export interface ${prefix}Objects {
    ${map(context.types, (t) => `${t.name}: ${prefix}_Type_${t.name}`)}
  }

  export interface ${prefix}Schema {
    context: ${options.contextType || "{}"};
    enums: ${prefix}Enums;
    objects: ${prefix}Objects;
    inputObjects: ${prefix}InputObjects;
    unions: ${prefix}Unions;
    scalars: ${prefix}Scalars;
    interfaces: ${prefix}Interfaces;
    allInputTypes: 
      | Extract<keyof ${prefix}InputObjects, string>
      | Extract<keyof ${prefix}Enums, string>
      | Extract<keyof ${prefix}Scalars, string>;
    allOutputTypes: 
      | Extract<keyof ${prefix}Objects, string>
      | Extract<keyof ${prefix}Enums, string>
      | Extract<keyof ${prefix}Unions, string>
      | Extract<keyof ${prefix}Interfaces, string>
      | Extract<keyof ${prefix}Scalars, string>;
  }

  export type Gen = ${prefix}Schema;

  declare global {
    interface GQLiteralGen extends ${prefix}Schema {}
  }
  `;

  const prettier = require("prettier");
  const content = prettier.format(tmpl, {
    parser: "typescript",
  });

  function fieldDef(typeName: string, field: Field) {
    return `${field.name}: {
      returnType: ${getReturnType(field)};
      args: {
        ${map(field.arguments, (arg) => {
          const name = `${arg.name}${arg.isRequired ? ":" : "?:"}`;
          return `${name} ${getArgType(arg)}`;
        })}
      }
    };`;
  }

  function backingType(name: string) {
    return backingTypes[name] || "unknown";
  }

  function getArgType(field: Field | Argument) {
    let type = "any";
    if (field.isInterface) {
      type = `${prefix}_Interface_${field.type}['backingType']`;
    } else if (field.isType) {
      type = `${prefix}_Type_${field.type}['backingType']`;
    } else if (field.isScalar && backingTypes[field.type]) {
      type = backingTypes[field.type];
    } else if (field.isEnum) {
      type = `${prefix}Enums["${field.type}"]`;
    }
    const nullSuffix = field.isRequired ? "" : "| null | undefined";
    if (field.isArray) {
      return `${type}${"[]".repeat(field.dimensionOfArray)}${nullSuffix}`;
    }
    return `${type}${nullSuffix}`;
  }

  function getReturnType(field: Field | Argument) {
    let type = "any";
    if (field.isInterface) {
      type = `${prefix}_Interface_${field.type}['backingType']`;
    } else if (field.isType) {
      type = `${prefix}_Type_${field.type}['backingType']`;
    } else if (field.isScalar && backingTypes[field.type]) {
      type = backingTypes[field.type];
    } else if (field.isEnum) {
      type = `${prefix}Enums["${field.type}"]`;
    }
    const nullPrefix = field.isRequired ? "" : "null | ";
    if (field.isArray) {
      const arraySuffix = "[]".repeat(field.dimensionOfArray);
      return `${nullPrefix}${type}${arraySuffix} | PromiseLike<${nullPrefix}${type}${arraySuffix}> | PromiseLike<${type}>${arraySuffix}`;
    }
    return `${nullPrefix}${type} | PromiseLike<${nullPrefix}${type}>`;
  }

  return [{ filename: typesFilePath, content }];
};

type Mapper<T> = (item: T, index: number) => string;

function map<T>(arr: T[], mapper: Mapper<T>, join = "\n") {
  return arr
    .map(mapper)
    .filter((f) => f)
    .join(join);
}

function interfaceFields(prefix: string, t: SchemaTemplateContext["types"][0]) {
  if (t.interfaces.length) {
    return `extends ${map(
      t.interfaces,
      (i) => `
      ${prefix}_Interface_${i}_Fields`,
      ", "
    )}`;
  }
  return "";
}

function nonInterfaceFields(
  ctx: SchemaTemplateContext,
  t: SchemaTemplateContext["types"][0]
) {
  const allInterfaceFields = new Set<string>();
  t.interfaces.forEach((name) => {
    const iface = ctx.interfaces.find((i) => i.name === name);
    if (iface) {
      iface.fields.forEach((field) => {
        allInterfaceFields.add(field.name);
      });
    }
  });
  return t.fields.filter((field) => !allInterfaceFields.has(field.name));
}
