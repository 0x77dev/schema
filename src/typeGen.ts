import fs from "fs";
import { compileTemplate } from "graphql-codegen-compiler";
import {
  CustomProcessingFunction,
  GraphQLSchema,
  schemaToTemplateContext,
  SchemaTemplateContext,
  Field,
  Argument,
} from "graphql-codegen-core";
import util from "util";
import path from "path";

const writeFile = util.promisify(fs.writeFile);

const SCALAR_TYPES = {
  String: "string",
  ID: "string",
  Float: "number",
  Date: "Date",
  JSON: "any",
  Boolean: "boolean",
};

export interface GQLiteralTypegenOptions {
  typesFilePath: string;
  backingTypes?: object;
  typeGenPrefix?: string;
  /**
   * Files to import as namespaces, for backing types
   */
  imports?: Record<string, string>;
  contextType?: any;
}

export async function typegen(
  options: GQLiteralTypegenOptions,
  schema: GraphQLSchema
) {
  const context = schemaToTemplateContext(schema);
  const data = await compileTemplate(makeTypes(options), context);
  await Promise.all(
    data.map(async ({ filename, content }) => {
      await writeFile(filename, content);
    })
  );
  return options;
}

export interface GQLiteralTypegenOptions {
  typesFilePath: string;
  backingTypes?: object;
  typeGenPrefix?: string;
  imports?: Record<string, string>;
}

export const makeTypes = (
  options: GQLiteralTypegenOptions
): CustomProcessingFunction => (context) => {
  const {
    typesFilePath,
    backingTypes: backing = {},
    imports = {},
    typeGenPrefix: prefix = "Generated",
  } = options;
  const backingTypes: Record<string, string> = {
    ...SCALAR_TYPES,
    ...backing,
  };
  const typeMap = context.rawSchema.getTypeMap();

  const tmpl = `
  /**
   * This file is autogenerated. Do not edit directly. 
   */
  ${map(Object.keys(imports || {}), (key) => {
    return `import * as ${key} from "${path
      .relative(typesFilePath, imports[key])
      .replace(/^\.\./, ".")
      .replace(/.tsx?$/, "")}"`;
  })}

  export type BaseScalarNames = "String" | "Int" | "Float" | "ID" | "Boolean";

  ${map(
    context.interfaces,
    (i) => `
      export type ${prefix}_Interface_${i.name} = {
        implementingTypes: ${map(i.implementingTypes, (t) => `"${t}"`, "|")};
        backingType: ${map(i.implementingTypes, backingType, "|")};
        fields: {
          ${map(i.fields, fieldDef)}
        }
      };
    `
  )}

  ${map(
    context.types,
    (t) => `
      export type ${prefix}_Type_${t.name} = {
        backingType: ${backingType(t.name)};
        fields: ${interfaceFields(prefix, t)} & {
          ${map(nonInterfaceFields(context, t), fieldDef)}
        }
      };
    `
  )}

  export type ${prefix}Scalars = {
    ${map(context.scalars, (scalar) => `${scalar.name}: any;`)}
  }
  export type ${prefix}Interfaces = {
    ${map(
      context.interfaces,
      (i) => `${i.name}: ${prefix}_Interface_${i.name}`
    )}
  }
  export type ${prefix}Unions = {}
  export type ${prefix}Enums = {
    ${map(context.enums, (e) => {
      return `${e.name}: ${map(
        e.values,
        (v) => JSON.stringify(v.value),
        "|"
      )};`;
    })}
  }
  export type ${prefix}InputObjects = {
    ${map(context.inputTypes, (i) => {
      return `${i.name}: any;`;
    })}
  }
  export type ${prefix}Objects = {
    ${map(context.types, (t) => `${t.name}: ${prefix}_Type_${t.name}`)}
  }

  export interface ${prefix}Schema {
    context: any;
    enums: ${prefix}Enums;
    objects: ${prefix}Objects;
    inputObjects: ${prefix}InputObjects;
    unions: ${prefix}Unions;
    scalars: ${prefix}Scalars;
    interfaces: ${prefix}Interfaces;
    
    // For simplicity in autocomplete:
    availableInputTypes: BaseScalarNames 
      | Extract<keyof ${prefix}InputObjects, string>
      | Extract<keyof ${prefix}Enums, string>
      | Extract<keyof ${prefix}Scalars, string>;
    availableOutputTypes: BaseScalarNames 
      | Extract<keyof ${prefix}Objects, string>
      | Extract<keyof ${prefix}Enums, string>
      | Extract<keyof ${prefix}Unions, string>
      | Extract<keyof ${prefix}Interfaces, string>
      | Extract<keyof ${prefix}Scalars, string>;
  }
  export type Gen = ${prefix}Schema;
  `;

  const prettier = require("prettier");
  const content = prettier.format(tmpl, {
    parser: "typescript",
  });

  function fieldDef(field: Field) {
    return `${field.name}: {
      returnType: ${getReturnType(field)};
      args: {
        ${map(field.arguments, (arg) => {
          return `${arg.name}: ${getType(arg)}`;
        })}
      }
    };`;
  }

  function backingType(name: string) {
    return backingTypes[name] || "any";
  }

  function getType(field: Field | Argument) {
    let type = "any";
    if (field.isInterface) {
      type = `${prefix}_Interface_${field.type}['backingType']`;
    } else if (field.isType) {
      type = `${prefix}_Type_${field.type}['backingType']`;
    } else if (field.isScalar && backingTypes[field.type]) {
      type = backingTypes[field.type];
    } else if (field.isEnum) {
      type = `${prefix}Enums["${field.type}"]`;
    }
    if (field.isArray) {
      return `${type}${"[]".repeat(field.dimensionOfArray)}`;
    }
    return type;
  }

  function getReturnType(field: Field | Argument) {
    let type = "any";
    if (field.isInterface) {
      type = `${prefix}_Interface_${field.type}['backingType']`;
    } else if (field.isType) {
      type = `${prefix}_Type_${field.type}['backingType']`;
    } else if (field.isScalar && backingTypes[field.type]) {
      type = backingTypes[field.type];
    } else if (field.isEnum) {
      type = `${prefix}Enums["${field.type}"]`;
    }
    const nullPrefix = field.isRequired ? "null | " : "";
    if (field.isArray) {
      const arraySuffix = "[]".repeat(field.dimensionOfArray);
      return `${nullPrefix}${type}${arraySuffix} | PromiseLike<${type}${arraySuffix}> | PromiseLike<${type}>${arraySuffix}`;
    }
    return `${nullPrefix}${type} | PromiseLike<${type}>`;
  }

  return [{ filename: options.typesFilePath, content }];
};

type Mapper<T> = (item: T, index: number) => string;

function map<T>(arr: T[], mapper: Mapper<T>, join = "\n") {
  return arr
    .map(mapper)
    .filter((f) => f)
    .join(join);
}

function interfaceFields(prefix: string, t: SchemaTemplateContext["types"][0]) {
  return map(t.interfaces, (i) => `${prefix}_Interface_${i}['fields']`);
}

function nonInterfaceFields(
  ctx: SchemaTemplateContext,
  t: SchemaTemplateContext["types"][0]
) {
  const interfaceFields = new Set<string>();
  t.interfaces.forEach((name) => {
    const iface = ctx.interfaces.find((i) => i.name === name);
    if (iface) {
      iface.fields.forEach((field) => {
        interfaceFields.add(field.name);
      });
    }
  });
  return t.fields.filter((field) => !interfaceFields.has(field.name));
}
