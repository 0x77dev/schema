import {
  GraphQLSchema,
  GraphQLNamedType,
  GraphQLObjectType,
  GraphQLInputObjectType,
  GraphQLArgs,
  GraphQLUnionType,
  GraphQLInterfaceType,
  GraphQLScalarType,
  isObjectType,
  isInputObjectType,
  isScalarType,
  GraphQLEnumType,
  isUnionType,
  isInterfaceType,
  isEnumType,
  isNamedType,
  GraphQLInputType,
  isNonNullType,
  isListType,
  GraphQLOutputType,
  GraphQLField,
  GraphQLArgument,
  GraphQLInputField,
} from "graphql";
import { dedent } from "./utils";

const SCALAR_TYPES = {
  Int: "number",
  String: "string",
  ID: "string",
  Float: "number",
  Date: "Date",
  JSON: "any",
  Boolean: "boolean",
};

export interface TypeBuilderOptions {
  /**
   * An array of additional strings to prefix on the header of the TS file
   */
  prefix?: string[];
}

/**
 * Unlike other codegen tools, we're only interested in 3 things here:
 *
 * 1. What are the "backing values" that are used in a resolver for a type.
 * 2. What are possible arguments for any output fields.
 * 3. What are valid "return values" for a resolver given the type it needs to resolve.
 *
 * We won't export all of these generated type, we will only use them for
 * completion. If you want types to use in your code, look into one of:
 *
 * https://github.com/dotansimha/graphql-code-generator
 * https://github.com/prisma/graphqlgen
 * https://github.com/apollographql/apollo-tooling
 */
export class TypeBuilder {
  protected objectTypes = new Set<GraphQLObjectType>();
  protected inputObjectTypes = new Set<GraphQLInputObjectType>();
  protected unionTypes = new Set<GraphQLUnionType>();
  protected interfaceTypes = new Set<GraphQLInterfaceType>();
  protected scalarTypes = new Set<GraphQLScalarType>();
  protected enumTypes = new Set<GraphQLEnumType>();
  protected scalarMapping: Record<string, string> = SCALAR_TYPES;

  constructor(
    protected schema: GraphQLSchema,
    protected options: TypeBuilderOptions = {}
  ) {
    Object.keys(schema.getTypeMap()).forEach((typeName) => {
      if (typeName.indexOf("__") === 0) {
        return;
      }
      // All types will be "unused" until we say otherwise,
      // if we need to strip them.
      const type = schema.getType(typeName);
      if (isObjectType(type)) {
        // If it's an object type, it potentially has a backing
        // value, which is either set on the field or on the schema.
        this.objectTypes.add(type);
      } else if (isInputObjectType(type)) {
        this.inputObjectTypes.add(type);
      } else if (isScalarType(type)) {
        this.scalarTypes.add(type);
      } else if (isUnionType(type)) {
        this.unionTypes.add(type);
      } else if (isInterfaceType(type)) {
        this.interfaceTypes.add(type);
      } else if (isEnumType(type)) {
        this.enumTypes.add(type);
      }
    });
  }

  /**
   * Formats the field name for adding to `${fieldName}${typeName}Args`
   * or `${fieldName}${typeName}Meta`
   */
  formatFieldNameForType(fieldName: string) {
    return fieldName
      .slice(0, 1)
      .toUpperCase()
      .concat(fieldName.slice(1));
  }

  generate() {
    return dedent`
    /* tslint:disable */
    /**
     * This file is automatically generated not make changes directly
     * This fill will regenerate when the server is started 
     * and NODE_ENV !== "production".
     * 
     * These types are only for internal use by gqliteral and subject 
     * to change. The "*Args" / InputObject types are the only types 
     * intended for external usage.
     * 
     * If you want more robust types to use in your code, look into one of:
     *
     * https://github.com/dotansimha/graphql-code-generator
     * https://github.com/prisma/graphqlgen
     * https://github.com/apollographql/apollo-tooling
     */
    ${this.options.prefix ? this.options.prefix.join("\n") : ""}

    // Maybe Promise
    type MP<T> = Promise<T> | T;
    
    ${this.allTypes()}
    
    ${this.generateGQLiteral()}

    declare global {
      interface GQLiteralGen extends GQLiteralGenTypes {}
    }

    export type Gen = GQLiteralGenTypes;
    `;
  }

  generatePretty() {
    try {
      require.resolve("prettier");
      return require("prettier").format(this.generate(), {
        parser: "typescript",
      });
    } catch (e) {
      return this.generate();
    }
  }

  /**
   * Return types are the potential contract that will
   * properly fulfill the the field's resolver. If we know the
   * backing type specifically, we'll use that, otherwise we can
   * infer it by:
   *
   * 1. If the field is nullable, or has a defaultValue, the type
   *    isn't required.
   *
   * 2. If there is a resolver on the backing type, we'll assume the
   *    field is not needed.
   *
   * 3. If there is an alias, we'll assume that field should be provided
   *    instead.
   */
  allTypes() {
    const argDefs: Record<string, Record<string, GraphQLField<any, any>>> = {};
    const argTypes: string[] = [];
    const backingTypes: string[] = [];
    const returnTypes: string[] = [];
    const returnTypeMap: Record<string, string> = {};

    const processField = (
      field: GraphQLField<any, any>,
      type: GraphQLObjectType | GraphQLInterfaceType
    ) => {
      if (field.args.length) {
        const argsTypeName = `${this.formatFieldNameForType(field.name)}${
          type.name
        }Args`;
        argDefs[type.name] = argDefs[type.name] || {};
        argDefs[type.name][field.name] = field;
        if (isObjectType(type)) {
          const predefined = type
            .getInterfaces()
            .map((i) => {
              if (argDefs[i.name] && argDefs[i.name][field.name]) {
                return `${this.formatFieldNameForType(field.name)}${
                  i.name
                }Args`;
              }
            })
            .filter((f) => f);
          if (predefined.length) {
            argTypes.push(
              `interface ${argsTypeName} extends ${predefined.join(", ")} {}`
            );
            return;
          }
        }
        argTypes.push(
          wrapInterface(
            argsTypeName,
            field.args.map((arg) => this.printArgOrField(arg))
          )
        );
      }
    };
    this.interfaceTypes.forEach((type) => {
      eachObj(type.getFields(), (field) => processField(field, type));
    });
    this.objectTypes.forEach((type) => {
      eachObj(type.getFields(), (field) => processField(field, type));
    });
    return dedent`
      ${argTypes.join("\n\n")}

      ${exp(
        wrapInterface(
          "GQLiteralGenArgTypes",
          mapObj(argDefs, (val, key) => {
            return dedent`
              ${key}: {
                ${mapObj(val, (field) => {
                  return `${field.name}: ${this.formatFieldNameForType(
                    field.name
                  )}Args;`;
                }).join("\n")}
              };
            `;
          })
        )
      )}

      ${exp(wrapInterface("GQLiteralGenBackingTypes", []))}

      ${exp(wrapInterface("GQLiteralGenReturnTypes", []))}
    `;
  }

  printArgOrField(arg: GraphQLArgument | GraphQLInputField): string {
    if (isNonNullType(arg.type)) {
      return `${arg.name}: ${this.printInputType(arg.type)}`;
    }
    return `${arg.name}?: ${this.printInputType(arg.type)}`;
  }

  /**
   * Input objects don't have arguments, so this should just be a
   * simple value mapping.
   */
  generateInputObjects() {
    return `${map(this.inputObjectTypes, (o) => this.makeInputObject(o))}`;
  }

  makeInputObject(o: GraphQLInputObjectType) {
    return exp(
      wrapInterface(
        o.name,
        mapObj(o.getFields(), (field) => this.printArgOrField(field))
      )
    );
  }

  printInputType(type: GraphQLInputType): string {
    if (isNonNullType(type)) {
      return this.printInputTypeValue(type.ofType);
    }
    return `null | ${this.printInputTypeValue(type)}`;
  }

  printInputTypeValue(type: GraphQLInputType): string {
    if (isListType(type)) {
      return `Array<${this.printInputType(type.ofType)}>`;
    }
    if (isScalarType(type)) {
      return this.scalarValue(type.name);
    }
    return `${type.name}`;
  }

  scalarValue(scalarName: string) {
    return this.scalarMapping[scalarName] || this.unknown();
  }

  unknown() {
    return "unknown";
  }

  getBackingType(obj: GraphQLObjectType) {
    return this.unknown();
  }

  generateObjectArgs() {
    return ``;
  }

  generateEnums() {
    return dedent`
      ${map(this.enumTypes, (node) => {
        return exp(
          wrapType(
            node.name,
            node.getValues().map((value) => `${JSON.stringify(value.value)}`),
            " | "
          )
        );
      })}
    `;
  }

  generateGQLiteral() {
    return exp(
      wrapInterface("GQLiteralGenTypes", [
        "argTypes: GQLiteralGenArgTypes",
        "backingTypes: GQLiteralGenBackingTypes",
        "returnTypes: GQLiteralGenReturnTypes",
      ])
    );
  }
}

function map<T>(
  nodes: Set<T> | Array<T>,
  iterator: (item: T, index: number) => string,
  join = "\n"
) {
  return Array.from(nodes)
    .map(iterator)
    .join(join);
}
function mapObj<T, R>(
  obj: Record<string, T>,
  mapper: (val: T, key: string, index: number) => R
) {
  return Object.keys(obj).map((key, index) => mapper(obj[key], key, index));
}
function eachObj<T>(
  obj: Record<string, T>,
  iter: (val: T, key: string, index: number) => void
) {
  Object.keys(obj).forEach((name, i) => iter(obj[name], name, i));
}

function exp(str: string) {
  return `export ${str}`;
}
function wrapInterface(name: string, items: string[], join = "\n"): string {
  return [`interface ${name} {`, items.join(join), "}"].join("\n");
}
function wrapType(name: string, items: string[], joinItems = "\n"): string {
  return `type ${name} = ${items.join(joinItems)}`;
}
